generator client {
  provider = "prisma-client-js"
}

enum MemoryType {
  FACT
  PREFERENCE
  LOG_EVENT
  REFERENCE
}

enum UserRole {
  USER
  ADMIN
}

enum RelationType {
  semantic
  topical
  temporal
}

enum OrgRole {
  ADMIN
  EDITOR
  VIEWER
}

enum DocumentStatus {
  PENDING
  PROCESSING
  COMPLETED
  FAILED
}

enum SourceType {
  EXTENSION
  DOCUMENT
  API
  INTEGRATION
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id                       String               @id @default(uuid()) @db.Uuid
  email                    String?              @unique
  password_hash            String?
  role                     UserRole             @default(USER)
  created_at               DateTime             @default(now())
  updated_at               DateTime             @default(now()) @updatedAt
  memories                 Memory[]
  memory_snapshots         MemorySnapshot[]
  token_usage              TokenUsage[]
  profile                  UserProfile?
  browsing_summaries       BrowsingSummary[]
  audit_logs               AuditLog[]
  organization_memberships OrganizationMember[]
  uploaded_documents       Document[]

  @@map("users")
}

model Organization {
  id          String               @id @default(uuid()) @db.Uuid
  name        String
  slug        String               @unique
  description String?
  created_at  DateTime             @default(now())
  updated_at  DateTime             @updatedAt
  members     OrganizationMember[]
  documents   Document[]
  memories    Memory[]

  @@map("organizations")
}

model OrganizationMember {
  id              String       @id @default(uuid()) @db.Uuid
  organization_id String       @db.Uuid
  user_id         String       @db.Uuid
  role            OrgRole      @default(VIEWER)
  created_at      DateTime     @default(now())
  organization    Organization @relation(fields: [organization_id], references: [id], onDelete: Cascade)
  user            User         @relation(fields: [user_id], references: [id], onDelete: Cascade)

  @@unique([organization_id, user_id])
  @@index([organization_id])
  @@index([user_id])
  @@map("organization_members")
}

model Document {
  id               String         @id @default(uuid()) @db.Uuid
  organization_id  String         @db.Uuid
  uploader_id      String         @db.Uuid
  filename         String
  original_name    String
  mime_type        String
  file_size        Int
  storage_path     String
  storage_provider String         @default("local")
  status           DocumentStatus @default(PENDING)
  error_message    String?
  page_count       Int?
  metadata         Json?
  created_at       DateTime       @default(now())
  updated_at       DateTime       @updatedAt
  organization     Organization   @relation(fields: [organization_id], references: [id], onDelete: Cascade)
  uploader         User           @relation(fields: [uploader_id], references: [id], onDelete: Cascade)
  chunks           DocumentChunk[]

  @@index([organization_id])
  @@index([uploader_id])
  @@index([status])
  @@index([organization_id, status])
  @@map("documents")
}

model DocumentChunk {
  id           String   @id @default(uuid()) @db.Uuid
  document_id  String   @db.Uuid
  chunk_index  Int
  content      String
  page_number  Int?
  char_start   Int?
  char_end     Int?
  memory_id    String?  @db.Uuid
  created_at   DateTime @default(now())
  document     Document @relation(fields: [document_id], references: [id], onDelete: Cascade)
  memory       Memory?  @relation(fields: [memory_id], references: [id], onDelete: SetNull)

  @@unique([document_id, chunk_index])
  @@index([document_id])
  @@index([memory_id])
  @@map("document_chunks")
}

model AuditLog {
  id                String   @id @default(uuid()) @db.Uuid
  user_id           String   @db.Uuid
  event_type        String
  event_category    String
  action            String
  metadata          Json?
  ip_address        String?
  user_agent        String?
  created_at        DateTime @default(now())
  user              User     @relation(fields: [user_id], references: [id], onDelete: Cascade)

  @@index([user_id])
  @@index([event_type])
  @@index([event_category])
  @@index([created_at])
  @@map("audit_logs")
}

model Memory {
  id                     String               @id @default(uuid()) @db.Uuid
  user_id                String               @db.Uuid
  source                 String
  url                    String?
  title                  String?
  content                String
  canonical_text         String?
  canonical_hash         String?
  memory_type            MemoryType           @default(LOG_EVENT)
  confidence_score       Float                @default(0.5)
  timestamp              BigInt
  created_at             DateTime             @default(now())
  full_content           String?
  page_metadata          Json?
  importance_score       Float?               @default(0.0)
  access_count           Int                  @default(0)
  last_accessed          DateTime             @default(now())
  source_type            SourceType?          @default(EXTENSION)
  organization_id        String?              @db.Uuid
  user                   User                 @relation(fields: [user_id], references: [id], onDelete: Cascade)
  organization           Organization?        @relation(fields: [organization_id], references: [id], onDelete: SetNull)
  related_memories       MemoryRelation[]     @relation("MemoryRelations")
  related_to_memories    MemoryRelation[]     @relation("RelatedMemories")
  query_related_memories QueryRelatedMemory[]
  document_chunks        DocumentChunk[]

  @@index([user_id])
  @@index([created_at])
  @@index([user_id, created_at])
  @@index([canonical_hash])
  @@index([url])
  @@index([memory_type])
  @@index([user_id, importance_score])
  @@index([user_id, memory_type])
  @@index([last_accessed])
  @@index([organization_id])
  @@index([source_type])
  @@unique([user_id, canonical_hash])
  @@map("memories")
}

model MemoryRelation {
  id                String       @id @default(uuid()) @db.Uuid
  memory_id         String       @db.Uuid
  related_memory_id String       @db.Uuid
  similarity_score  Float
  relation_type     RelationType @default(semantic)
  created_at        DateTime     @default(now())
  memory            Memory       @relation("MemoryRelations", fields: [memory_id], references: [id], onDelete: Cascade)
  related_memory    Memory       @relation("RelatedMemories", fields: [related_memory_id], references: [id], onDelete: Cascade)

  @@unique([memory_id, related_memory_id])
  @@index([memory_id])
  @@index([related_memory_id])
  @@index([memory_id, related_memory_id])
  @@index([similarity_score])
  @@index([relation_type])
  @@map("memory_relations")
}

model MemorySnapshot {
  id           String   @id @default(uuid()) @db.Uuid
  user_id      String   @db.Uuid
  raw_text     String
  created_at   DateTime @default(now())
  user         User     @relation(fields: [user_id], references: [id], onDelete: Cascade)

  @@index([user_id])
  @@index([user_id, created_at])
  @@map("memory_snapshots")
}

/// Each search query event (stores only hashed embedding reference)
model QueryEvent {
  id             String               @id @default(uuid()) @db.Uuid
  user_id        String
  query          String
  embedding_hash String
  created_at     DateTime             @default(now())
  related        QueryRelatedMemory[]

  @@index([user_id])
  @@index([user_id, created_at])
  @@map("query_events")
}

/// Links a query event to matching memories
model QueryRelatedMemory {
  id             String     @id @default(uuid()) @db.Uuid
  query_event_id String     @db.Uuid
  memory_id      String     @db.Uuid
  rank           Int
  score          Float
  created_at     DateTime   @default(now())
  query_event    QueryEvent @relation(fields: [query_event_id], references: [id], onDelete: Cascade)
  memory         Memory     @relation(fields: [memory_id], references: [id], onDelete: Cascade)

  @@unique([query_event_id, memory_id])
  @@map("query_related_memories")
}

model TokenUsage {
  id            String   @id @default(uuid()) @db.Uuid
  user_id       String   @db.Uuid
  operation_type String
  input_tokens  Int
  output_tokens Int
  model_used   String?
  created_at    DateTime @default(now())
  user          User     @relation(fields: [user_id], references: [id], onDelete: Cascade)

  @@index([user_id])
  @@index([created_at])
  @@index([user_id, created_at])
  @@index([operation_type])
  @@map("token_usage")
}

model UserProfile {
  id                  String   @id @default(uuid()) @db.Uuid
  user_id             String   @unique @db.Uuid
  static_profile_json Json?
  static_profile_text String? @db.Text
  dynamic_profile_json Json?
  dynamic_profile_text String? @db.Text
  last_updated        DateTime @default(now()) @updatedAt
  last_memory_analyzed DateTime?
  version             Int      @default(1)
  user                User     @relation(fields: [user_id], references: [id], onDelete: Cascade)

  @@index([user_id])
  @@index([last_updated])
  @@map("user_profiles")
}

model BrowsingSummary {
  id                 String   @id @default(uuid()) @db.Uuid
  user_id            String   @db.Uuid
  period_type        String
  period_start       DateTime
  period_end         DateTime
  wow_facts          Json?
  narrative_summary  String?  @db.Text
  domain_stats       Json?
  topics_explored    Json?
  categories_explored Json?
  time_estimates     Json?
  key_insights       Json?
  memory_ids         Json?
  created_at         DateTime @default(now())
  updated_at         DateTime @default(now()) @updatedAt
  user               User     @relation(fields: [user_id], references: [id], onDelete: Cascade)

  @@index([user_id])
  @@index([period_type])
  @@index([period_start])
  @@index([period_end])
  @@index([user_id, period_type])
  @@index([user_id, period_type, period_start])
  @@map("browsing_summaries")
}

